#include "timer.h"


void TIM3_Init(u16 Period,u16 Prescaler)
{
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	NVIC_InitTypeDef         NVIC_InitStructure;

	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //Ê±ÖÓÊ¹ÄÜ
	
	
	TIM_TimeBaseStructure.TIM_Period          = Period; //ÉèÖÃÔÚÏÂÒ»¸ö¸üÐÂÊÂ¼þ×°Èë»î¶¯µÄ×Ô¶¯ÖØ×°ÔØ¼Ä´æÆ÷ÖÜÆÚµÄÖµ	
	TIM_TimeBaseStructure.TIM_Prescaler       = Prescaler; //ÉèÖÃÓÃÀ´×÷ÎªTIMxÊ±ÖÓÆµÂÊ³ýÊýµÄÔ¤·ÖÆµÖµ
	TIM_TimeBaseStructure.TIM_ClockDivision   = TIM_CKD_DIV1; //ÉèÖÃÊ±ÖÓ·Ö¸î:TDTS = Tck_tim
	TIM_TimeBaseStructure.TIM_CounterMode     = TIM_CounterMode_Up;  //TIMÏòÉÏ¼ÆÊýÄ£Ê½
	
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //¸ù¾ÝÖ¸¶¨µÄ²ÎÊý³õÊ¼»¯TIMxµÄÊ±¼ä»ùÊýµ¥Î»
 
	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //Ê¹ÄÜÖ¸¶¨µÄTIM3ÖÐ¶Ï,ÔÊÐí¸üÐÂÖÐ¶Ï
	//ÖÐ¶ÏÓÅÏÈ¼¶NVICÉèÖÃ
	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM3ÖÐ¶Ï
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //ÏÈÕ¼ÓÅÏÈ¼¶
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //´ÓÓÅÏÈ¼¶
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQÍ¨µÀ±»Ê¹ÄÜ
	NVIC_Init(&NVIC_InitStructure);  //³õÊ¼»¯NVIC¼Ä´æÆ÷
	TIM_Cmd(TIM3, ENABLE);  //Ê¹ÄÜTIMx					 
}


void TIM3_PWM_Init(u16 Period,u16 Prescaler)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	TIM_OCInitTypeDef  TIM_OCInitStructure;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	//Ê¹ÄÜ¶¨Ê±Æ÷3Ê±ÖÓ
 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  | RCC_APB2Periph_AFIO, ENABLE);  //Ê¹ÄÜGPIOÍâÉèºÍAFIO¸´ÓÃ¹¦ÄÜÄ£¿éÊ±ÖÓ
	
	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3²¿·ÖÖØÓ³Éä  TIM3_CH2->PB5    
 
   //ÉèÖÃ¸ÃÒý½ÅÎª¸´ÓÃÊä³ö¹¦ÄÜ,Êä³öTIM3 CH2µÄPWMÂö³å²¨ÐÎ	GPIOB.5
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //TIM_CH2
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //¸´ÓÃÍÆÍìÊä³ö
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);//³õÊ¼»¯GPIO
 
   //³õÊ¼»¯TIM3
	TIM_TimeBaseStructure.TIM_Period          = Period; //ÉèÖÃÔÚÏÂÒ»¸ö¸üÐÂÊÂ¼þ×°Èë»î¶¯µÄ×Ô¶¯ÖØ×°ÔØ¼Ä´æÆ÷ÖÜÆÚµÄÖµ	
	TIM_TimeBaseStructure.TIM_Prescaler       = Prescaler; //ÉèÖÃÓÃÀ´×÷ÎªTIMxÊ±ÖÓÆµÂÊ³ýÊýµÄÔ¤·ÖÆµÖµ
	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //ÉèÖÃÊ±ÖÓ·Ö¸î:TDTS = Tck_tim
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down;  //TIM¼ÆÊýÄ£Ê½
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //¸ù¾ÝTIM_TimeBaseInitStructÖÐÖ¸¶¨µÄ²ÎÊý³õÊ¼»¯TIMxµÄÊ±¼ä»ùÊýµ¥Î»
	
	//³õÊ¼»¯TIM3 Channel2 PWMÄ£Ê½	 
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //Ñ¡Ôñ¶¨Ê±Æ÷Ä£Ê½:TIMÂö³å¿í¶Èµ÷ÖÆÄ£Ê½2
 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //±È½ÏÊä³öÊ¹ÄÜ
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //Êä³ö¼«ÐÔ:TIMÊä³ö±È½Ï¼«ÐÔ¸ß
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);  //¸ù¾ÝTÖ¸¶¨µÄ²ÎÊý³õÊ¼»¯ÍâÉèTIM3 OC2

	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);  //Ê¹ÄÜTIM3ÔÚCCR2ÉÏµÄÔ¤×°ÔØ¼Ä´æÆ÷
 
	TIM_Cmd(TIM3, ENABLE);  //Ê¹ÄÜTIM3
}


//¶¨Ê±Æ÷3ÖÐ¶Ï·þÎñ³ÌÐò
void TIM3_IRQHandler(void)   //TIM3ÖÐ¶Ï
{
	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)  //¼ì²éTIM3¸üÐÂÖÐ¶Ï·¢ÉúÓë·ñ
		{
		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  //Çå³ýTIMx¸üÐÂÖÐ¶Ï±êÖ¾
			
			if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_4))
			{
				GPIO_WriteBit(GPIOA, GPIO_Pin_4, Bit_RESET);
			}
			else
			{
				GPIO_WriteBit(GPIOA, GPIO_Pin_4, Bit_SET);
			}
		}
}



void TIM2_Ecoder_Init(void)
{
/********Ecoder******/
//peripheral clock enable
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
				RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE);
//REMAP
		GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);//RM0008 P178
//gpio set
        GPIOA->CRH&=0X0FFFFFFF;//RM0008 P170
		//&=0X00FFFFFF--RESET PA15 TO 0
        GPIOA->CRH|=0X40000000;
		//&=0X00FFFFFF--SET PA15 TO 0X4--FLOATING INPUT
		GPIOB->CRL&=0XFFFF0FFF;//RM0008 P170
		//&=0X00FFFFFF--RESET PB3 TO 0
        GPIOB->CRL|=0X00004000;
		//&=0X00FFFFFF--SET PB3 TO 0X4--FLOATING INPUT
//TIM set
	/*STEP1*/
        TIM2->SMCR |= 1<<0;//RM0008 406
		//3<<0--SMS=11b(Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges
		//depending on the level of the other input.)
	/*STEP2*/
				TIM2->CCER &= ~(1<<1);//RM0008 416
		//~(1<<1)--CC1P=0b(remind channel configured as input)non-inverted: capture is done on a rising edge of IC1. When used as external trigger, IC1
		//is non-inverted.
        TIM2->DIER|=1<<0;//RM0008 408
		//0--Update interrupt enable
        TIM2->DIER|=1<<6;//RM0008 408
		//6--Trigger interrupt enable
        TIM2->PSC = 0X0000;//RM0008 418
		//Prescaler value
        TIM2->ARR = 0XFFFF;//RM0008 418
		//In upcounting mode, the counter counts from 0 to the auto-reload value (content of the
		//TIMx_ARR register), then restarts from 0 and generates a counter overflow event.
        TIM2->CR1 &=~(3<<8);//RM0008 403
		//~(3<<8)--CKD=00b(tDTS = tCK_INT)
        TIM2->CR1 &=~(3<<5);//RM0008 403
        //~(3<<5)--CMS=00b(Edge-aligned mode) he counter counts up or down depending on the direction bit
		//(DIR).
        TIM2->CCMR1 |= 1<<0;//RM0008 412
		//1<<0--CC1S=01b(CC1 channel is configured as input, IC1 is mapped on TI1)
        TIM2->CCMR1 |= 1<<8;//RM0008 412
		//1<<8--CC2S=01b(CC2 channel is configured as input, IC2 is mapped on TI2)
        TIM2->CCMR1 |= 0<<4;//RM0008 412
		//3<<4--0100: fSAMPLING=fDTS/2, N=6
        TIM2->CNT = 0X0000;
        TIM2->CR1 |= 0x01;//Counter enable
	
}




